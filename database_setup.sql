-- ========================================
-- REFINED IDEMPOTENT SUPABASE SCHEMA
-- ========================================

-- 0. Extensions
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 1. Core Tables (Using IF NOT EXISTS)
CREATE TABLE IF NOT EXISTS bot_stats (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bot_started_at TIMESTAMPTZ DEFAULT NOW(),
    total_posts_all_time INTEGER DEFAULT 0,
    last_run_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Fix for "last_seen" legacy column compatibility
DO $$ 
BEGIN 
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'bot_stats' AND column_name = 'last_seen') THEN
        ALTER TABLE bot_stats ALTER COLUMN last_seen DROP NOT NULL;
    END IF;
END $$;

CREATE TABLE IF NOT EXISTS daily_stats (
    date DATE PRIMARY KEY,
    posts_count INTEGER DEFAULT 0,
    anime_posts INTEGER DEFAULT 0,
    world_posts INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS runs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    date DATE NOT NULL,
    slot INTEGER NOT NULL,
    scheduled_at TIMESTAMPTZ,
    started_at TIMESTAMPTZ DEFAULT NOW(),
    finished_at TIMESTAMPTZ,
    status TEXT CHECK (status IN ('started', 'success', 'failed', 'skipped')),
    posts_sent INTEGER DEFAULT 0,
    source_counts JSONB,
    error TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(date, slot)
);

CREATE TABLE IF NOT EXISTS posted_news (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    normalized_title TEXT NOT NULL,
    full_title TEXT NOT NULL,
    article_url TEXT,
    telegraph_url TEXT,
    posted_date DATE NOT NULL,
    posted_at TIMESTAMPTZ DEFAULT NOW(),
    source TEXT NOT NULL,
    category TEXT,
    channel_id TEXT,
    channel_type TEXT CHECK (channel_type IN ('anime', 'world')),
    status TEXT DEFAULT 'sent' CHECK (status IN ('attempted', 'sent', 'failed')),
    run_id BIGINT REFERENCES runs(id) ON DELETE SET NULL,
    slot INTEGER,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Schema Hardening (Ensuring columns exist for migrations)
DO $$ 
BEGIN 
    -- posted_news updates
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='posted_news' AND column_name='status') THEN
        ALTER TABLE posted_news ADD COLUMN status TEXT DEFAULT 'sent';
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='posted_news' AND column_name='channel_type') THEN
        ALTER TABLE posted_news ADD COLUMN channel_type TEXT CHECK (channel_type IN ('anime', 'world'));
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='posted_news' AND column_name='article_url') THEN
        ALTER TABLE posted_news ADD COLUMN article_url TEXT;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='posted_news' AND column_name='telegraph_url') THEN
        ALTER TABLE posted_news ADD COLUMN telegraph_url TEXT;
    END IF;
    
    -- daily_stats updates
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='daily_stats' AND column_name='anime_posts') THEN
        ALTER TABLE daily_stats ADD COLUMN anime_posts INTEGER DEFAULT 0;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='daily_stats' AND column_name='world_posts') THEN
        ALTER TABLE daily_stats ADD COLUMN world_posts INTEGER DEFAULT 0;
    END IF;
END $$;

-- 3. Functions
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 4. Triggers (Drop before create for idempotency)
DROP TRIGGER IF EXISTS set_posted_news_timestamp ON posted_news;
CREATE TRIGGER set_posted_news_timestamp
    BEFORE UPDATE ON posted_news
    FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp();

DROP TRIGGER IF EXISTS set_daily_stats_timestamp ON daily_stats;
CREATE TRIGGER set_daily_stats_timestamp
    BEFORE UPDATE ON daily_stats
    FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp();

DROP TRIGGER IF EXISTS set_bot_stats_timestamp ON bot_stats;
CREATE TRIGGER set_bot_stats_timestamp
    BEFORE UPDATE ON bot_stats
    FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp();

-- 5. Logic Functions (Atomic Increments)
CREATE OR REPLACE FUNCTION increment_daily_stats(row_date DATE)
RETURNS VOID AS $$
BEGIN
    INSERT INTO daily_stats (date, posts_count)
    VALUES (row_date, 1)
    ON CONFLICT (date)
    DO UPDATE SET 
        posts_count = daily_stats.posts_count + 1,
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION increment_bot_stats()
RETURNS VOID AS $$
BEGIN
    -- Using specific ID 1 for single bot stats row
    INSERT INTO bot_stats (id, total_posts_all_time, last_run_at)
    VALUES (1, 1, NOW())
    ON CONFLICT (id) DO UPDATE SET 
        total_posts_all_time = bot_stats.total_posts_all_time + 1,
        last_run_at = NOW(),
        updated_at = NOW();
END;
$$ LANGUAGE plpgsql;

-- 6. Helper Functions (Views logic)
CREATE OR REPLACE FUNCTION get_daily_summary(target_date DATE)
RETURNS TABLE(
    total_posts BIGINT,
    anime_posts BIGINT,
    world_posts BIGINT,
    sources JSON
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::BIGINT as total_posts,
        COUNT(*) FILTER (WHERE channel_type = 'anime')::BIGINT as anime_posts,
        COUNT(*) FILTER (WHERE channel_type = 'world')::BIGINT as world_posts,
        json_agg(json_build_object('source', source, 'count', cnt)) as sources
    FROM (
        SELECT source, COUNT(*) as cnt
        FROM posted_news
        WHERE posted_date = target_date AND status = 'sent'
        GROUP BY source
    ) source_counts;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION check_duplicate(
    title_to_check TEXT,
    days_back INTEGER DEFAULT 7
)
RETURNS TABLE(
    is_duplicate BOOLEAN,
    matched_title TEXT,
    similarity FLOAT
) AS $$
DECLARE
    normalized TEXT;
    min_date DATE;
BEGIN
    normalized := LOWER(REGEXP_REPLACE(title_to_check, '[^\w\s]', '', 'g'));
    min_date := CURRENT_DATE - days_back;
    
    RETURN QUERY
    SELECT 
        TRUE as is_duplicate,
        full_title as matched_title,
        SIMILARITY(normalized_title, normalized) as similarity
    FROM posted_news
    WHERE posted_date >= min_date
        AND SIMILARITY(normalized_title, normalized) > 0.85
    ORDER BY similarity DESC
    LIMIT 1;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, NULL::TEXT, 0::FLOAT;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION cleanup_old_posts(days_to_keep INTEGER DEFAULT 30)
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM posted_news
    WHERE posted_date < CURRENT_DATE - days_to_keep
        AND status = 'sent';
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- 7. Indexes
CREATE INDEX IF NOT EXISTS idx_posted_news_lookup ON posted_news (normalized_title, posted_date);
CREATE INDEX IF NOT EXISTS idx_posted_news_date ON posted_news (posted_date DESC);
CREATE INDEX IF NOT EXISTS idx_posted_news_source ON posted_news (source, posted_date);
CREATE INDEX IF NOT EXISTS idx_posted_news_status ON posted_news (status, posted_date);
CREATE INDEX IF NOT EXISTS idx_runs_date_slot ON runs (date, slot);

-- 8. Row Level Security (Policies) - Idempotent
-- Enable RLS
ALTER TABLE posted_news ENABLE ROW LEVEL SECURITY;
ALTER TABLE daily_stats ENABLE ROW LEVEL SECURITY;
ALTER TABLE runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE bot_stats ENABLE ROW LEVEL SECURITY;

-- Service role policies
DROP POLICY IF EXISTS "Service role full access on posted_news" ON posted_news;
CREATE POLICY "Service role full access on posted_news"
    ON posted_news FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

DROP POLICY IF EXISTS "Service role full access on daily_stats" ON daily_stats;
CREATE POLICY "Service role full access on daily_stats"
    ON daily_stats FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

DROP POLICY IF EXISTS "Service role full access on runs" ON runs;
CREATE POLICY "Service role full access on runs"
    ON runs FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

DROP POLICY IF EXISTS "Service role full access on bot_stats" ON bot_stats;
CREATE POLICY "Service role full access on bot_stats"
    ON bot_stats FOR ALL
    TO service_role
    USING (true)
    WITH CHECK (true);

-- Authenticated user policies
DROP POLICY IF EXISTS "Users can view posted_news" ON posted_news;
CREATE POLICY "Users can view posted_news"
    ON posted_news FOR SELECT
    TO authenticated
    USING (true);

DROP POLICY IF EXISTS "Users can view daily_stats" ON daily_stats;
CREATE POLICY "Users can view daily_stats"
    ON daily_stats FOR SELECT
    TO authenticated
    USING (true);

DROP POLICY IF EXISTS "Users can view runs" ON runs;
CREATE POLICY "Users can view runs"
    ON runs FOR SELECT
    TO authenticated
    USING (true);

DROP POLICY IF EXISTS "Users can view bot_stats" ON bot_stats;
CREATE POLICY "Users can view bot_stats"
    ON bot_stats FOR SELECT
    TO authenticated
    USING (true);

-- 9. Views
DROP VIEW IF EXISTS recent_activity CASCADE;
DROP VIEW IF EXISTS daily_summary CASCADE;
-- Handle potential table conflict for source_health
DROP TABLE IF EXISTS source_health CASCADE; 
DROP VIEW IF EXISTS source_health CASCADE;

CREATE OR REPLACE VIEW recent_activity AS
SELECT 
    pn.posted_date,
    pn.source,
    pn.channel_type,
    pn.status,
    pn.full_title,
    pn.posted_at
FROM posted_news pn
WHERE pn.posted_date >= CURRENT_DATE - INTERVAL '7 days'
ORDER BY pn.posted_at DESC;

CREATE OR REPLACE VIEW daily_summary AS
SELECT 
    ds.date,
    ds.posts_count as total_posts,
    COALESCE(anime.cnt, 0) as anime_posts,
    COALESCE(world.cnt, 0) as world_posts
FROM daily_stats ds
LEFT JOIN (
    SELECT posted_date, COUNT(*) as cnt 
    FROM posted_news 
    WHERE channel_type = 'anime' AND status = 'sent'
    GROUP BY posted_date
) anime ON ds.date = anime.posted_date
LEFT JOIN (
    SELECT posted_date, COUNT(*) as cnt 
    FROM posted_news 
    WHERE channel_type = 'world' AND status = 'sent'
    GROUP BY posted_date
) world ON ds.date = world.posted_date
WHERE ds.date >= CURRENT_DATE - INTERVAL '30 days'
ORDER BY ds.date DESC;

CREATE OR REPLACE VIEW source_health AS
SELECT 
    source,
    COUNT(*) as total_posts,
    COUNT(*) FILTER (WHERE status = 'sent') as successful_posts,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_posts,
    COUNT(*) FILTER (WHERE status = 'attempted') as attempted_posts,
    MAX(posted_at) as last_post_time,
    ROUND(
        COUNT(*) FILTER (WHERE status = 'sent')::NUMERIC / 
        NULLIF(COUNT(*)::NUMERIC, 0) * 100, 
        2
    ) as success_rate
FROM posted_news
WHERE posted_date >= CURRENT_DATE - INTERVAL '7 days'
GROUP BY source
ORDER BY total_posts DESC;

-- 10. Initialize Global Row
INSERT INTO bot_stats (id, bot_started_at, total_posts_all_time)
VALUES (1, NOW(), 0)
ON CONFLICT (id) DO NOTHING;

-- 11. Comments
COMMENT ON TABLE posted_news IS 'Tracks all posted news with strong deduplication';
COMMENT ON COLUMN posted_news.status IS 'Post status: attempted (before send), sent (success), failed (error)';
COMMENT ON FUNCTION increment_daily_stats IS 'Atomically increment daily post count';
COMMENT ON FUNCTION increment_bot_stats IS 'Atomically increment all-time post count';

-- ========================================
-- SETUP COMPLETE
-- ========================================
